<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Harp.tt" #><##>
<#@ output extension=".Interface.cs" #>
<#
var namespaceName = Host.ResolveAssemblyReference("$(MSBuildProjectName)");
var firmwarePath = Host.ResolveAssemblyReference("$(HarpFirmwarePath)");
var metadataPath = !string.IsNullOrEmpty(firmwarePath)
    ? Host.ResolvePath(firmwarePath)
    : Path.GetDirectoryName(Host.TemplateFile);
var templateFileName = Path.GetFileNameWithoutExtension(Host.TemplateFile);
var metadataFileName = Path.Combine(metadataPath, templateFileName) + ".yml";

var deviceMetadata = TemplateHelper.ReadDeviceMetadata(metadataFileName);
var publicRegisters = deviceMetadata.Registers.Where(register => register.Value.Visibility == RegisterVisibility.Public);
var commandMetadata = publicRegisters.Where(register => (register.Value.RegisterType & RegisterType.Command) != 0).ToList();
var eventMetadata = publicRegisters
    .Where(register => (register.Value.RegisterType & RegisterType.Event) != 0)
    .Select(register => (register.Value.RegisterType & RegisterType.Command) != 0
        ? new KeyValuePair<string, RegisterInfo>(register.Key + nameof(RegisterType.Event), register.Value)
        : register)
    .ToList();

var deviceName = deviceMetadata.Device;
var deviceClassName = deviceName + "Device";
var eventClassName = deviceName + "Event";
var commandClassName = deviceName + "Command";
#>
using Bonsai;
using Bonsai.Harp;
<#
foreach (var ns in Host.StandardImports)
{
    WriteLine("using " + ns + ";");
}
#>
using System.ComponentModel;
using System.Reactive.Linq;
using System.Xml.Serialization;

namespace <#= namespaceName #>
{
    /// <summary>
    /// Represents an observable source of messages from the <#= deviceName #> device connected
    /// at the specified serial port.
    /// </summary>
    [Combinator(MethodName = nameof(Generate))]
    [WorkflowElementCategory(ElementCategory.Source)]
    [Description("Generates events and processes commands for the <#= deviceName #> device.")]
    public partial class <#= deviceClassName #>
    {
        readonly Device device = new Device(whoAmI: <#= deviceMetadata.WhoAmI #>);

        /// <summary>
        /// Gets or sets the name of the serial port used to communicate with the
        /// <#= deviceName #> device.
        /// </summary>
        [TypeConverter(typeof(PortNameConverter))]
        [Description("The name of the serial port used to communicate with the <#= deviceName #> device.")]
        public string PortName
        {
            get { return device.PortName; }
            set { device.PortName = value; }
        }

        /// <summary>
        /// Connects to the specified serial port and returns an observable sequence of Harp messages
        /// coming from the device.
        /// </summary>
        /// <returns>The observable sequence of Harp messages produced by the device.</returns>
        public IObservable<HarpMessage> Generate()
        {
            return device.Generate();
        }

        /// <summary>
        /// Connects to the specified serial port and sends the observable sequence of Harp messages.
        /// The return value is an observable sequence of Harp messages coming from the device.
        /// </summary>
        /// <param name="source">An observable sequence of Harp messages to send to the device.</param>
        /// <returns>The observable sequence of Harp messages produced by the device.</returns>
        public IObservable<HarpMessage> Generate(IObservable<HarpMessage> source)
        {
            return device.Generate(source);
        }
    }
<#
if (eventMetadata.Count > 0)
{
#>

    /// <summary>
    /// Represents an operator which filters and selects specific event messages
    /// reported by the <#= deviceName #> device.
    /// </summary>
<#
foreach (var register in eventMetadata)
{
#>
    /// <seealso cref="<#= register.Key #>"/>
<#
}
#>
<#
foreach (var register in eventMetadata)
{
#>
    [XmlInclude(typeof(<#= register.Key #>))]
<#
}
#>
    [Description("Filters and selects specific event messages reported by the <#= deviceName #> device.")]
    public partial class <#= eventClassName #> : EventBuilder
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= eventClassName #>"/> class.
        /// </summary>
        public <#= eventClassName #>()
        {
            Event = new <#= eventMetadata.First().Key #>();
        }
    }
<#
foreach (var registerMetadata in eventMetadata)
{
    var register = registerMetadata.Value;
    var payloadSuffix = TemplateHelper.GetPayloadTypeSuffix(register.PayloadType, register.PayloadLength);
    var payloadSelector = $"message.GetPayload{payloadSuffix}()";
    var interfaceType = TemplateHelper.GetInterfaceType(registerMetadata.Key, register);
    var conversion = TemplateHelper.GetEventConversion(register, payloadSelector);
    var summaryDescription = string.IsNullOrEmpty(register.Description)
        ? $"from register {registerMetadata.Key}"
        : $"that {char.ToLower(register.Description[0])}{register.Description.Substring(1).TrimEnd('.')}";
#>

    /// <summary>
    /// Represents an operator which filters and selects a sequence of event messages
    /// <#= summaryDescription #>.
    /// </summary>
    [DesignTimeVisible(false)]
    [Description("Filters and selects a sequence of event messages <#= summaryDescription #>.")]
    public partial class <#= registerMetadata.Key #> : Combinator<HarpMessage, <#= interfaceType #>>
    {<#
    if (register.PayloadSpec != null && string.IsNullOrEmpty(register.Converter))
    {
#>

        static <#= interfaceType #> ParsePayload(<#= register.PayloadInterfaceType #> payload)
        {
            <#= interfaceType #> result;
<#
        foreach (var member in register.PayloadSpec)
        {
            var memberConversion = TemplateHelper.GetPayloadMemberParser(
                member.Value,
                "payload",
                register.PayloadType);
#>
            result.<#= member.Key #> = <#= memberConversion #>;
<#
        }
#>
            return result;
        }
<#
    }#>
        
        /// <summary>
        /// Returns the payload data for the <see cref="<#= registerMetadata.Key #>"/> event message.
        /// </summary>
        /// <param name="message">
        /// A <see cref="HarpMessage"/> encoding the event payload.
        /// </param>
        /// <returns>
        /// A value representing the message payload <#= summaryDescription #>.
        /// </returns>
        public static <#= interfaceType #> Parse(HarpMessage message)
        {
            return <#= conversion #>;
        }

        /// <summary>
        /// Filters and selects an observable sequence of event messages
        /// <#= summaryDescription #>.
        /// </summary>
        /// <param name="source">The sequence of Harp event messages.</param>
        /// <returns>
        /// A sequence of <see cref="<#= interfaceType #>"/> objects representing the
        /// register payload.
        /// </returns>
        public override IObservable<<#= interfaceType #>> Process(IObservable<HarpMessage> source)
        {
            return source.Event(address: <#= register.Address #>).Select(Parse);
        }
    }
<#
}
#>
<#
} // eventMetadata.Count > 0
#>
<#
if (commandMetadata.Count > 0)
{
#>

    /// <summary>
    /// Represents an operator which creates standard command messages for the
    /// <#= deviceName #> device.
    /// </summary>
<#
foreach (var register in commandMetadata)
{
#>
    /// <seealso cref="<#= register.Key #>"/>
<#
}
#>
<#
foreach (var register in commandMetadata)
{
#>
    [XmlInclude(typeof(<#= register.Key #>))]
<#
}
#>
    [Description("Creates standard command messages for the <#= deviceName #> device.")]
    public partial class <#= commandClassName #> : CommandBuilder
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= commandClassName #>"/> class.
        /// </summary>
        public <#= commandClassName #>()
        {
            Command = new <#= commandMetadata.First().Key #>();
        }
    }
<#
foreach (var registerMetadata in commandMetadata)
{
    var register = registerMetadata.Value;
    var payloadSuffix = TemplateHelper.GetPayloadTypeSuffix(register.PayloadType);
    var interfaceType = TemplateHelper.GetInterfaceType(registerMetadata.Key, register);
    var conversion = TemplateHelper.GetCommandConversion(register, "value");
    var defaultValue = TemplateHelper.GetDefaultValueAssignment(register.DefaultValue, register.MinValue);
    var summaryDescription = string.IsNullOrEmpty(register.Description)
        ? $"to write on register {registerMetadata.Key}"
        : $"that {char.ToLower(register.Description[0])}{register.Description.Substring(1).TrimEnd('.')}";
#>

    /// <summary>
    /// Represents an operator that creates a sequence of command messages
    /// <#= summaryDescription #>.
    /// </summary>
    [DesignTimeVisible(false)]
    [WorkflowElementCategory(ElementCategory.Transform)]
    [Description("Creates a sequence of command messages <#= summaryDescription #>.")]
    public partial class <#= registerMetadata.Key #> : Combinator<HarpMessage>
    {<#
    if (register.PayloadSpec != null)
    {
        foreach (var member in register.PayloadSpec)
        {
            var memberType = TemplateHelper.GetInterfaceType(member.Value, register.PayloadType);
            defaultValue = TemplateHelper.GetDefaultValueAssignment(member.Value.DefaultValue, member.Value.MinValue);
            var memberDescription = string.IsNullOrEmpty(member.Value.Description)
                ? $"to write on payload member {member.Key}"
                : $"that {char.ToLower(member.Value.Description[0])}{member.Value.Description.Substring(1).TrimEnd('.')}";
#>

        /// <summary>
        /// Gets or sets a value <#= memberDescription #>.
        /// </summary>
<#
            if (member.Value.MinValue.HasValue || member.Value.MaxValue.HasValue)
            {
#>
        <#= TemplateHelper.GetRangeAttributeDeclaration(member.Value.MinValue, member.Value.MaxValue) #>
        [Editor(DesignTypes.NumericUpDownEditor, DesignTypes.UITypeEditor)]
<#
            }
#>
        [Description("<#= member.Value.Description #>")]
        public <#= memberType #> <#= member.Key #> { get; set; }<#= defaultValue #>
<#
        }
    }
    else
    {
#>

        /// <summary>
        /// Gets or sets the value <#= summaryDescription #>.
        /// </summary>
<#
        if (register.MinValue.HasValue || register.MaxValue.HasValue)
        {
#>
        <#= TemplateHelper.GetRangeAttributeDeclaration(register.MinValue, register.MaxValue) #>
        [Editor(DesignTypes.NumericUpDownEditor, DesignTypes.UITypeEditor)]
<#
        }
#>
        [Description("The value <#= summaryDescription #>.")]
        public <#= interfaceType #> Value { get; set; }<#= defaultValue #>
<#
    }
#>
<#
    if (register.PayloadSpec != null && string.IsNullOrEmpty(register.Converter))
    {
#>

        static <#= register.PayloadInterfaceType #> FormatPayload(<#= interfaceType #> value)
        {
            <#= register.PayloadInterfaceType #> result;
<#
        if (register.PayloadLength > 0)
        {
#>
            result = new <#= TemplateHelper.GetInterfaceType(register.PayloadType) #>[<#= register.PayloadLength #>];
<#
        }
#>
<#
        var assigned = new bool[Math.Max(1, register.PayloadLength)];
        foreach (var member in register.PayloadSpec)
        {
            var payloadIndex = member.Value.Offset.GetValueOrDefault(0);
            var memberIndexer = member.Value.Offset.HasValue ? $"[{member.Value.Offset}]" : string.Empty;
            var memberConversion = TemplateHelper.GetPayloadMemberFormatter(
                member.Value,
                $"value.{member.Key}",
                register.PayloadType,
                assigned[payloadIndex]);
            assigned[payloadIndex] = true;
#>
            result<#= memberIndexer #><#= memberConversion #>;
<#
        }
#>
            return result;
        }
<#
    }#>

        /// <summary>
        /// Creates a command message for the <see cref="<#= registerMetadata.Key #>"/> register.
        /// </summary>
        /// <param name="value">
        /// A value representing the command message payload
        /// <#= summaryDescription #>.
        /// </param>
        /// <returns>
        /// A <see cref="HarpMessage"/> object representing the command message.
        /// </returns>
        public static HarpMessage Format(<#= interfaceType #> value)
        {
            return HarpCommand.Write<#= payloadSuffix #>(address: <#= register.Address #>, <#= conversion #>);
        }

        /// <summary>
        /// Creates an observable sequence of command messages
        /// <#= summaryDescription #>.
        /// </summary>
        /// <param name="source">
        /// A sequence of <see cref="<#= interfaceType #>"/> objects representing the
        /// register payload.
        /// </param>
        /// <returns>
        /// A sequence of <see cref="HarpMessage"/> objects representing each
        /// command message.
        /// </returns>
        public override IObservable<HarpMessage> Process<TSource>(IObservable<TSource> source)
        {
<#
    if (register.PayloadSpec != null)
    {
#>
            return source.Select(_ =>
            {
                <#= interfaceType #> value;
<#
        foreach (var member in register.PayloadSpec)
        {
#>
                value.<#= member.Key #> = <#= member.Key #>;
<#
        }
#>
                return Format(value);
            });
<#
    }
    else
    {
#>
            return source.Select(_ => Format(Value));
<#
    }
#>
        }
    }
<#
}
#>
<#
} // commandMetadata.Count > 0
#>
<#
foreach (var registerMetadata in deviceMetadata.Registers)
{
    var register = registerMetadata.Value;
    if (register.PayloadSpec == null) continue;
    var interfaceType = TemplateHelper.GetInterfaceType(registerMetadata.Key, register);
#>

    /// <summary>
    /// Represents the payload of the <#= registerMetadata.Key #> register.
    /// </summary>
    public struct <#= interfaceType #>
    {<#
    foreach (var member in register.PayloadSpec)
    {
        var memberType = TemplateHelper.GetInterfaceType(member.Value, register.PayloadType);
#>

        /// <summary>
        /// <#= member.Value.Description #>
        /// </summary>
        public <#= memberType #> <#= member.Key #>;
<#
    }
#>
    }
<#
}
#>
<#
foreach (var bitMask in deviceMetadata.BitMasks)
{
    var mask = bitMask.Value;
#>

    /// <summary>
    /// <#= mask.Description #>
    /// </summary>
    [Flags]
    public enum <#= bitMask.Key #> : <#= mask.InterfaceType #>
    {
<#
    var bitIndex = 0;
    foreach (var bitField in mask.Bits)
    {
#>
        <#= bitField.Key #> = 0x<#= bitField.Value.ToString("X") #><#= ++bitIndex < mask.Bits.Count ? "," : string.Empty #>
<#
    }
#>
    }
<#
}
#>
<#
foreach (var groupMask in deviceMetadata.GroupMasks)
{
    var mask = groupMask.Value;
#>

    /// <summary>
    /// <#= mask.Description #>
    /// </summary>
    public enum <#= groupMask.Key #> : <#= mask.InterfaceType #>
    {
<#
    var memberIndex = 0;
    foreach (var member in mask.Values)
    {
#>
        <#= member.Key #> = <#= member.Value #><#= ++memberIndex < mask.Values.Count ? "," : string.Empty #>
<#
    }
#>
    }
<#
}
#>
}
