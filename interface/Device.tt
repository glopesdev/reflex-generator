<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ parameter name="Namespace" type="string" #>
<#@ parameter name="MetadataPath" type="string" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Interface.tt" #><##>
<#@ output extension=".cs" #>
<#
var deviceMetadata = TemplateHelper.ReadDeviceMetadata(MetadataPath);
var publicRegisters = deviceMetadata.Registers.Where(register => register.Value.Visibility == RegisterVisibility.Public).ToList();
var deviceName = deviceMetadata.Device;
#>
using Bonsai;
using Bonsai.Harp;
<#
foreach (var ns in Host.StandardImports)
{
    WriteLine("using " + ns + ";");
}
#>
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reactive.Linq;
using System.Xml.Serialization;

namespace <#= Namespace #>
{
    /// <summary>
    /// Generates events and processes commands for the <#= deviceName #> device connected
    /// at the specified serial port.
    /// </summary>
    [Combinator(MethodName = nameof(Generate))]
    [WorkflowElementCategory(ElementCategory.Source)]
    [Description("Generates events and processes commands for the <#= deviceName #> device.")]
    public partial class Device : Bonsai.Harp.Device, INamedElement
    {
        /// <summary>
        /// Represents the unique identity class of the <see cref="<#= deviceName #>"/> device.
        /// This field is constant.
        /// </summary>
        public const int WhoAmI = <#= deviceMetadata.WhoAmI #>;

        /// <summary>
        /// Initializes a new instance of the <see cref="Device"/> class.
        /// </summary>
        public Device() : base(WhoAmI) { }

        string INamedElement.Name => nameof(<#= deviceName #>);

        /// <summary>
        /// Gets a read-only mapping from address to register type.
        /// </summary>
        public static new IReadOnlyDictionary<int, Type> RegisterMap { get; } = new Dictionary<int, Type>
            (Bonsai.Harp.Device.RegisterMap.ToDictionary(entry => entry.Key, entry => entry.Value))
        {
<#
int registerIndex = 0;
foreach (var register in publicRegisters)
{
#>
            { <#= register.Value.Address #>, typeof(<#= register.Key #>) }<#= ++registerIndex < publicRegisters.Count ? "," : string.Empty #>
<#
}
#>
        };
    }

    /// <summary>
    /// Represents an operator that groups the sequence of <see cref="<#= deviceName #>"/>" messages by register name.
    /// </summary>
    [Description("Groups the sequence of <#= deviceName #> messages by register name.")]
    public partial class GroupByRegister : Combinator<HarpMessage, IGroupedObservable<string, HarpMessage>>
    {
        /// <summary>
        /// Groups an observable sequence of <see cref="<#= deviceName #>"/> messages
        /// by register name.
        /// </summary>
        /// <param name="source">The sequence of Harp device messages.</param>
        /// <returns>
        /// A sequence of observable groups, each of which corresponds to a unique
        /// <see cref="<#= deviceName #>"/> register.
        /// </returns>
        public override IObservable<IGroupedObservable<string, HarpMessage>> Process(IObservable<HarpMessage> source)
        {
            return source.GroupBy(message => Device.RegisterMap[message.Address]);
        }
    }
<#
if (publicRegisters.Count > 0)
{
#>

    /// <summary>
    /// Represents an operator that filters register-specific messages
    /// reported by the <see cref="<#= deviceName #>"/> device.
    /// </summary>
<#
foreach (var register in publicRegisters)
{
#>
    /// <seealso cref="<#= register.Key #>"/>
<#
}
#>
<#
foreach (var register in publicRegisters)
{
#>
    [XmlInclude(typeof(<#= register.Key #>))]
<#
}
#>
    [Description("Filters register-specific messages reported by the <#= deviceName #> device.")]
    public class FilterMessage : FilterMessageBuilder, INamedElement
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FilterMessage"/> class.
        /// </summary>
        public FilterMessage()
        {
            Register = new Bonsai.Expressions.TypeMapping<<#= publicRegisters.First().Key #>>();
        }

        string INamedElement.Name
        {
            get => $"{nameof(<#= deviceName #>)}.{GetElementDisplayName(Register?.GetType().GenericTypeArguments[0])}";
        }
    }

    /// <summary>
    /// Represents an operator which filters and selects specific messages
    /// reported by the <#= deviceName #> device.
    /// </summary>
<#
foreach (var register in publicRegisters)
{
#>
    /// <seealso cref="<#= register.Key #>"/>
<#
}
#>
<#
foreach (var register in publicRegisters)
{
#>
    [XmlInclude(typeof(<#= register.Key #>))]
<#
}
#>
<#
foreach (var register in publicRegisters)
{
#>
    [XmlInclude(typeof(Timestamped<#= register.Key #>))]
<#
}
#>
    [Description("Filters and selects specific messages reported by the <#= deviceName #> device.")]
    public partial class Parse : ParseBuilder, INamedElement
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Parse"/> class.
        /// </summary>
        public Parse()
        {
            Register = new <#= publicRegisters.First().Key #>();
        }

        string INamedElement.Name => $"{nameof(<#= deviceName #>)}.{GetElementDisplayName(Register)}";
    }

    /// <summary>
    /// Represents an operator which formats a sequence of values as specific
    /// <#= deviceName #> register messages.
    /// </summary>
<#
foreach (var register in publicRegisters)
{
#>
    /// <seealso cref="<#= register.Key #>"/>
<#
}
#>
<#
foreach (var register in publicRegisters)
{
#>
    [XmlInclude(typeof(<#= register.Key #>))]
<#
}
#>
    [Description("Formats a sequence of values as specific <#= deviceName #> register messages.")]
    public partial class Format : FormatBuilder, INamedElement
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Format"/> class.
        /// </summary>
        public Format()
        {
            Register = new <#= publicRegisters.First().Key #>();
        }

        string INamedElement.Name => $"{nameof(<#= deviceName #>)}.{GetElementDisplayName(Register)}";
    }
<#
foreach (var registerMetadata in publicRegisters)
{
    var register = registerMetadata.Value;
    var hasConverter = register.HasConverter;
    var rawPayload = register.Converter == MemberConverter.RawPayload;
    var hasEvent = (register.Access & RegisterAccess.Event) != 0;
    var allowWrite = (register.Access & RegisterAccess.Write) != 0;
    var defaultMessageType = hasEvent ? "Event" : (allowWrite ? "Write" : "Read");
    var interfaceType = TemplateHelper.GetInterfaceType(registerMetadata.Key, register);
    var parsePayloadSuffix = rawPayload
        ? string.Empty
        : TemplateHelper.GetPayloadTypeSuffix(register.Type, register.Length);
    var parsePayloadSelector = $"message.GetPayload{parsePayloadSuffix}()";
    var parseConversion = TemplateHelper.GetParseConversion(register, parsePayloadSelector);

    var payloadValueSelector = "payload.Value";
    var timestampedPayloadSelector = $"message.GetTimestampedPayload{parsePayloadSuffix}()";
    var timestampedParseConversion = TemplateHelper.GetParseConversion(register, payloadValueSelector);

    var formatPayloadSuffix = rawPayload ? "Payload" : TemplateHelper.GetPayloadTypeSuffix(register.Type);
    var formatConversion = TemplateHelper.GetFormatConversion(register, "value");
    if (rawPayload) formatConversion = $"PayloadType.{register.Type}, {formatConversion}";
    var summaryDescription = string.IsNullOrEmpty(register.Description)
        ? $"manipulates messages from register {registerMetadata.Key}"
        : $"{char.ToLower(register.Description[0])}{register.Description.Substring(1).TrimEnd('.')}";
#>

    /// <summary>
    /// Represents a register that <#= summaryDescription #>.
    /// </summary>
    [Description("<#= register.Description #>")]
    public partial class <#= registerMetadata.Key #>
    {
        /// <summary>
        /// Represents the address of the <see cref="<#= registerMetadata.Key #>"/> register. This field is constant.
        /// </summary>
        public const int Address = <#= register.Address #>;

        /// <summary>
        /// Represents the payload type of the <see cref="<#= registerMetadata.Key #>"/> register. This field is constant.
        /// </summary>
        public const PayloadType RegisterType = PayloadType.<#= register.Type #>;

        /// <summary>
        /// Represents the length of the <see cref="<#= registerMetadata.Key #>"/> register. This field is constant.
        /// </summary>
        public const int RegisterLength = <#= Math.Max(1, register.Length) #>;
<#
    if (hasConverter)
    {
#>

        private static partial <#= interfaceType #> ParsePayload(<#= register.PayloadInterfaceType #> payload);
<#
    }
    else if (register.PayloadSpec != null)
    {
        foreach (var member in register.PayloadSpec)
        {
            if (member.Value.HasConverter)
            {
                var memberType = TemplateHelper.GetInterfaceType(member.Value, register.Type);
#>

        private static partial <#= memberType #> ParsePayload<#= member.Key #>(<#= register.PayloadInterfaceType #> payload<#= member.Key #>);
<#
            }
        }
#>

        static <#= interfaceType #> ParsePayload(<#= register.PayloadInterfaceType #> payload)
        {
            <#= interfaceType #> result;
<#
        foreach (var member in register.PayloadSpec)
        {
            var memberConversion = TemplateHelper.GetPayloadMemberParser(
                member.Key,
                member.Value,
                "payload",
                register.Type);
#>
            result.<#= member.Key #> = <#= memberConversion #>;
<#
        }
#>
            return result;
        }
<#
    }

    if (hasConverter)
    {
#>

        private static partial <#= register.PayloadInterfaceType #> FormatPayload(<#= interfaceType #> value);
<#
    }
    else if (register.PayloadSpec != null)
    {
        foreach (var member in register.PayloadSpec)
        {
            if (member.Value.HasConverter)
            {
                var paramName = CamelCaseNamingConvention.Instance.Apply(member.Key);
                var memberType = TemplateHelper.GetInterfaceType(member.Value, register.Type);
#>

        private static partial <#= register.PayloadInterfaceType #> FormatPayload<#= member.Key #>(<#= memberType #> <#= paramName #>);
<#
            }
        }
#>

        static <#= register.PayloadInterfaceType #> FormatPayload(<#= interfaceType #> value)
        {
            <#= register.PayloadInterfaceType #> result;
<#
        if (register.Length > 0)
        {
#>
            result = new <#= TemplateHelper.GetInterfaceType(register.Type) #>[<#= register.Length #>];
<#
        }
#>
<#
        var assigned = new bool[Math.Max(1, register.Length)];
        foreach (var member in register.PayloadSpec)
        {
            var payloadIndex = member.Value.Offset.GetValueOrDefault(0);
            var memberIndexer = member.Value.Offset.HasValue ? $"[{member.Value.Offset}]" : string.Empty;
            var memberConversion = TemplateHelper.GetPayloadMemberFormatter(
                member.Key,
                member.Value,
                $"value.{member.Key}",
                register.Type,
                assigned[payloadIndex]);
            assigned[payloadIndex] = true;
#>
            result<#= memberIndexer #><#= memberConversion #>;
<#
        }
#>
            return result;
        }
<#
    }#>

        /// <summary>
        /// Returns the payload data for <see cref="<#= registerMetadata.Key #>"/> register messages.
        /// </summary>
        /// <param name="message">A <see cref="HarpMessage"/> object representing the register message.</param>
        /// <returns>A value representing the message payload.</returns>
        public static <#= interfaceType #> GetPayload(HarpMessage message)
        {
            return <#= parseConversion #>;
        }

        /// <summary>
        /// Returns the timestamped payload data for <see cref="<#= registerMetadata.Key #>"/> register messages.
        /// </summary>
        /// <param name="message">A <see cref="HarpMessage"/> object representing the register message.</param>
        /// <returns>A value representing the timestamped message payload.</returns>
        public static Timestamped<<#= interfaceType #>> GetTimestampedPayload(HarpMessage message)
        {
<#
    if (timestampedParseConversion != payloadValueSelector)
    {
#>
            var payload = <#= timestampedPayloadSelector #>;
            return Timestamped.Create(<#= timestampedParseConversion #>, payload.Seconds);
<#
    }
    else
    {
#>
            return <#= timestampedPayloadSelector #>;
<#
    }
#>
        }

        /// <summary>
        /// Returns a Harp message for the <see cref="<#= registerMetadata.Key #>"/> register.
        /// </summary>
        /// <param name="messageType">The type of the Harp message.</param>
        /// <param name="value">The value to be stored in the message payload.</param>
        /// <returns>
        /// A <see cref="HarpMessage"/> object for the <see cref="<#= registerMetadata.Key #>"/> register
        /// with the specified message type and payload.
        /// </returns>
        public static HarpMessage FromPayload(MessageType messageType, <#= interfaceType #> value)
        {
            return HarpMessage.From<#= formatPayloadSuffix #>(Address, messageType, <#= formatConversion #>);
        }

        /// <summary>
        /// Returns a timestamped Harp message for the <see cref="<#= registerMetadata.Key #>"/>
        /// register.
        /// </summary>
        /// <param name="timestamp">The timestamp of the message payload, in seconds.</param>
        /// <param name="messageType">The type of the Harp message.</param>
        /// <param name="value">The value to be stored in the message payload.</param>
        /// <returns>
        /// A <see cref="HarpMessage"/> object for the <see cref="<#= registerMetadata.Key #>"/> register
        /// with the specified message type, timestamp, and payload.
        /// </returns>
        public static HarpMessage FromPayload(double timestamp, MessageType messageType, <#= interfaceType #> value)
        {
            return HarpMessage.From<#= formatPayloadSuffix #>(Address, timestamp, messageType, <#= formatConversion #>);
        }
    }

    /// <summary>
    /// Provides methods for manipulating timestamped messages from the
    /// <#= registerMetadata.Key #> register.
    /// </summary>
    /// <seealso cref="<#= registerMetadata.Key #>"/>
    [Description("Filters and selects timestamped messages from the <#= registerMetadata.Key #> register.")]
    public partial class Timestamped<#= registerMetadata.Key #>
    {
        /// <summary>
        /// Represents the address of the <see cref="<#= registerMetadata.Key #>"/> register. This field is constant.
        /// </summary>
        public const int Address = <#= registerMetadata.Key #>.Address;

        /// <summary>
        /// Returns timestamped payload data for <see cref="<#= registerMetadata.Key #>"/> register messages.
        /// </summary>
        /// <param name="message">A <see cref="HarpMessage"/> object representing the register message.</param>
        /// <returns>A value representing the timestamped message payload.</returns>
        public static Timestamped<<#= interfaceType #>> GetPayload(HarpMessage message)
        {
            return <#= registerMetadata.Key #>.GetTimestampedPayload(message);
        }
    }
<#
}
#>

    /// <summary>
    /// Represents an operator which creates standard message payloads for the
    /// <#= deviceName #> device.
    /// </summary>
<#
foreach (var register in publicRegisters)
{
#>
    /// <seealso cref="Create<#= register.Key #>Payload"/>
<#
}
#>
<#
foreach (var register in publicRegisters)
{
#>
    [XmlInclude(typeof(Create<#= register.Key #>Payload))]
<#
}
#>
    [Description("Creates standard message payloads for the <#= deviceName #> device.")]
    public partial class CreateMessage : CreateMessageBuilder, INamedElement
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateMessage"/> class.
        /// </summary>
        public CreateMessage()
        {
            Payload = new Create<#= publicRegisters.First().Key #>Payload();
        }

        string INamedElement.Name => $"{nameof(<#= deviceName #>)}.{GetElementDisplayName(Payload)}";
    }
<#
foreach (var registerMetadata in publicRegisters)
{
    var register = registerMetadata.Value;
    var interfaceType = TemplateHelper.GetInterfaceType(registerMetadata.Key, register);
    var defaultValue = TemplateHelper.GetDefaultValueAssignment(register.DefaultValue, register.MinValue);
    var summaryDescription = string.IsNullOrEmpty(register.Description)
        ? $"for register {registerMetadata.Key}"
        : $"that {char.ToLower(register.Description[0])}{register.Description.Substring(1).TrimEnd('.')}";
#>

    /// <summary>
    /// Represents an operator that creates a sequence of message payloads
    /// <#= summaryDescription #>.
    /// </summary>
    [DisplayName("<#= registerMetadata.Key #>Payload")]
    [WorkflowElementCategory(ElementCategory.Transform)]
    [Description("Creates a sequence of message payloads <#= summaryDescription #>.")]
    public partial class Create<#= registerMetadata.Key #>Payload : HarpCombinator
    {<#
    if (register.PayloadSpec != null)
    {
        foreach (var member in register.PayloadSpec)
        {
            var memberType = TemplateHelper.GetInterfaceType(member.Value, register.Type);
            defaultValue = TemplateHelper.GetDefaultValueAssignment(member.Value.DefaultValue, member.Value.MinValue);
            var memberDescription = string.IsNullOrEmpty(member.Value.Description)
                ? $"to write on payload member {member.Key}"
                : $"that {char.ToLower(member.Value.Description[0])}{member.Value.Description.Substring(1).TrimEnd('.')}";
#>

        /// <summary>
        /// Gets or sets a value <#= memberDescription #>.
        /// </summary>
<#
            if (member.Value.MinValue.HasValue || member.Value.MaxValue.HasValue)
            {
#>
        <#= TemplateHelper.GetRangeAttributeDeclaration(member.Value.MinValue, member.Value.MaxValue) #>
        [Editor(DesignTypes.NumericUpDownEditor, DesignTypes.UITypeEditor)]
<#
            }
#>
        [Description("<#= member.Value.Description #>")]
        public <#= memberType #> <#= member.Key #> { get; set; }<#= defaultValue #>
<#
        }
    }
    else
    {
#>

        /// <summary>
        /// Gets or sets the value <#= summaryDescription #>.
        /// </summary>
<#
        if (register.MinValue.HasValue || register.MaxValue.HasValue)
        {
#>
        <#= TemplateHelper.GetRangeAttributeDeclaration(register.MinValue, register.MaxValue) #>
        [Editor(DesignTypes.NumericUpDownEditor, DesignTypes.UITypeEditor)]
<#
        }
#>
        [Description("The value <#= summaryDescription #>.")]
        public <#= interfaceType #> Value { get; set; }<#= defaultValue #>
<#
    }
#>

        /// <summary>
        /// Creates an observable sequence that contains a single message
        /// <#= summaryDescription #>.
        /// </summary>
        /// <returns>
        /// A sequence containing a single <see cref="HarpMessage"/> object
        /// representing the created message payload.
        /// </returns>
        public IObservable<HarpMessage> Process()
        {
            return Process(Observable.Return(System.Reactive.Unit.Default));
        }

        /// <summary>
        /// Creates an observable sequence of message payloads
        /// <#= summaryDescription #>.
        /// </summary>
        /// <typeparam name="TSource">
        /// The type of the elements in the <paramref name="source"/> sequence.
        /// </typeparam>
        /// <param name="source">
        /// The sequence containing the notifications used for emitting message payloads.
        /// </param>
        /// <returns>
        /// A sequence of <see cref="HarpMessage"/> objects representing each
        /// created message payload.
        /// </returns>
        public IObservable<HarpMessage> Process<TSource>(IObservable<TSource> source)
        {
<#
    if (register.PayloadSpec != null)
    {
#>
            return source.Select(_ =>
            {
                <#= interfaceType #> value;
<#
        foreach (var member in register.PayloadSpec)
        {
#>
                value.<#= member.Key #> = <#= member.Key #>;
<#
        }
#>
                return <#= registerMetadata.Key #>.FromPayload(MessageType, value);
            });
<#
    }
    else
    {
#>
            return source.Select(_ => <#= registerMetadata.Key #>.FromPayload(MessageType, Value));
<#
    }
#>
        }
    }
<#
}
#>
<#
} // publicRegisters.Count > 0
#>
<#
var payloadTypes = new HashSet<string>();
foreach (var registerMetadata in deviceMetadata.Registers)
{
    var register = registerMetadata.Value;
    if (register.PayloadSpec == null) continue;
    var interfaceType = TemplateHelper.GetInterfaceType(registerMetadata.Key, register);
    if (!payloadTypes.Add(interfaceType)) continue;
    var registerName = TemplateHelper.RemoveSuffix(interfaceType, "Payload");
#>

    /// <summary>
    /// Represents the payload of the <#= registerName #> register.
    /// </summary>
    public struct <#= interfaceType #>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= interfaceType #>"/> structure.
        /// </summary>
<#
    foreach (var member in register.PayloadSpec)
    {
        var paramName = CamelCaseNamingConvention.Instance.Apply(member.Key);
#>
        /// <param name="<#= paramName #>"><#= member.Value.Description #></param>
<#
    }
#>
        public <#= interfaceType #>(
<#
    var paramIndex = 0;
    foreach (var member in register.PayloadSpec)
    {
        var paramName = CamelCaseNamingConvention.Instance.Apply(member.Key);
        var paramType = TemplateHelper.GetInterfaceType(member.Value, register.Type);
#>
            <#= paramType #> <#= paramName #><#= ++paramIndex < register.PayloadSpec.Count ? "," : ")" #>
<#
    }
#>
        {
<#
    foreach (var member in register.PayloadSpec)
    {
        var paramName = CamelCaseNamingConvention.Instance.Apply(member.Key);
#>
            <#= member.Key #> = <#= paramName #>;
<#
    }
#>
        }
<#
    foreach (var member in register.PayloadSpec)
    {
        var memberType = TemplateHelper.GetInterfaceType(member.Value, register.Type);
#>

        /// <summary>
        /// <#= member.Value.Description #>
        /// </summary>
        public <#= memberType #> <#= member.Key #>;
<#
    }
#>
    }
<#
}
#>
<#
foreach (var bitMask in deviceMetadata.BitMasks)
{
    var mask = bitMask.Value;
#>

    /// <summary>
    /// <#= mask.Description #>
    /// </summary>
    [Flags]
    public enum <#= bitMask.Key #> : <#= mask.InterfaceType #>
    {
<#
    var bitIndex = 0;
    foreach (var bitField in mask.Bits)
    {
        var fieldInfo = bitField.Value;
#>
<#
        if (!string.IsNullOrEmpty(fieldInfo.Description))
        {
            if (bitIndex > 0) WriteLine("");
#>
        /// <summary>
        /// <#= fieldInfo.Description #>
        /// </summary>
<#
        }
#>
        <#= bitField.Key #> = 0x<#= fieldInfo.Value.ToString("X") #><#= ++bitIndex < mask.Bits.Count ? "," : string.Empty #>
<#
    }
#>
    }
<#
}
#>
<#
foreach (var groupMask in deviceMetadata.GroupMasks)
{
    var mask = groupMask.Value;
#>

    /// <summary>
    /// <#= mask.Description #>
    /// </summary>
    public enum <#= groupMask.Key #> : <#= mask.InterfaceType #>
    {
<#
    var memberIndex = 0;
    foreach (var member in mask.Values)
    {
        var memberInfo = member.Value;
#>
<#
        if (!string.IsNullOrEmpty(memberInfo.Description))
        {
            if (memberIndex > 0) WriteLine("");
#>
        /// <summary>
        /// <#= memberInfo.Description #>
        /// </summary>
<#
        }
#>
        <#= member.Key #> = <#= memberInfo.Value #><#= ++memberIndex < mask.Values.Count ? "," : string.Empty #>
<#
    }
#>
    }
<#
}
#>
}
